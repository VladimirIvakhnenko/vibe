6.  **Снова запросим рекомендации.**
    Результат может измениться, так как веса в графе были обновлены.
    ```bash
    curl http://localhost:8080/api/recommendations
    ```
    
## Работа с реализацией и её расширение

Этот прототип спроектирован с учётом возможного расширения. Ниже описаны ключевые точки для модификации.

### 1. Добавление треков и связей

Все треки и связи между ними на данный момент "зашиты" в коде для простоты демонстрации. Чтобы добавить новые треки или изменить связи, нужно отредактировать бин `trackGraph()` в файле `src/main/java/org/recomendation/configs/RecommendationConfig.java`.

**Пример добавления трека и связи:**
```java
// ... в методе trackGraph()
// 1. Создаём и добавляем новый трек в граф
Track newTrack = new Track("t11", "New Song", "New Artist");
graph.addVertex(newTrack);

// 2. Находим трек, с которым хотим его связать (например, по исполнителю)
Track existingTrack = graph.getTrackById("t1"); // Предположим, t1 - трек того же исполнителя

// 3. Добавляем ребро (связь) с начальным весом 1.0
if (existingTrack != null) {
    graph.addEdge(newTrack, existingTrack);
    graph.setEdgeWeight(graph.getEdge(newTrack, existingTrack), 1.0);
}
//...
```

### 2. Изменение алгоритма рекомендаций

Основная логика рекомендаций находится в классе `RecommendationService`. Метод `recommendTracks(int limit)` содержит полный алгоритм. Вы можете изменить его, например:
-   Изменить глубину поиска (BFS).
-   Заменить BFS на другой алгоритм обхода графа (например, поиск в глубину - DFS).
-   Добавить учёт других факторов при расчёте рейтинга (например, жанр или год выпуска трека).

### 3. Настройка весов

Веса, которые добавляются при лайке, дизлайке или прослушивании, заданы в `LikeService`. Вы можете легко изменить эти значения:

-   `likeTrack()`: `updateWeight(track1, track2, 1.0)` - вес лайка.
-   `dislikeTrack()`: `updateWeight(track1, track2, -1.0)` - вес дизлайка.
-   `listenTrack()`: `updateWeight(track1, track2, 0.5)` - вес прослушивания.

### 4. Подключение к реальной базе данных

Текущая реализация использует in-memory хранилища (`TrackGraph` и `UserPreferenceRepository`). Для полноценного приложения их следует заменить на компоненты, работающие с настоящей базой данных:
-   **`TrackGraph`** можно заменить на реализацию, работающую с графовой СУБД, такой как **Neo4j**.
-   **`UserPreferenceRepository`** можно заменить на репозиторий, использующий любую реляционную (PostgreSQL, MySQL) или NoSQL (MongoDB) базу данных для хранения предпочтений пользователей. 